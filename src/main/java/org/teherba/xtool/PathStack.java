/*  PathStack.java - Bean for a start or end of an element in a linear representation of a W3C Schema
 *  @(#) $Id: PathStack.java 40 2008-09-08 06:41:22Z gfis $
 *  Automatically generated by etc/xslt/genRecord.xsl at 2007-09-20T17:09:55+02:00
 *  2017-05-28: javadoc 1.8
 *  2008-02-13: Java 1.5 types
 *  2007-11-09: Georg Fischer
 *
 *  Caution, this file should be encoded in UTF-8: äöüÄÖÜß
 */
/*
 * Copyright 2006 Dr. Georg Fischer <punctum at punctum dot kom>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.teherba.xtool;
import  org.teherba.xtool.PathElement;
import  java.util.Stack;
import  org.apache.logging.log4j.Logger;
import  org.apache.logging.log4j.LogManager;

/** Bean for a start or end of an element in a linear representation of a W3C Schema
 *  @author Dr. Georg Fischer
 */
public class PathStack extends Stack<PathElement>/*1.5>*/ {
    /** Source code version */
    public static final String CVSID = "@(#) $Id: PathStack.java 40 2008-09-08 06:41:22Z gfis $";

    /** log4j logger (category) */
    private Logger log;

    /** No-args Constructor
     */
    public PathStack() {
        super(); // create an empty stack
        log = LogManager.getLogger(PathStack.class.getName());
    } // constructor

    //-----------------------------------
    // overridden and overloaded methods
    //-----------------------------------

    /** Push an element whose properties are specified
     *  @param topElement path stack element to be written on top of stack
     */
    public PathElement push(PathElement topElement) {
        // System.err.println(topElement.getTypeName() + "@" + topElement.getName());
        return super.push(topElement);
    } // push with parameters

    /** Push an element whose properties are specified
     *  @param typeName name of the type associated with the element
     *  @param name name of the element
     *  @param combIndex index of the element's tooth in the comb
     *  @return new element just pushed
     */
    public PathElement push(String typeName, String name, int combIndex) {
        return super.push(new PathElement(typeName, name, combIndex));
    } // push with parameters

    /** Pop an element
     *  @return path element from top of stack, or null if stack is empty;
     *  do not throw an exception if the stack is empty
     */
    public PathElement pop() {
        PathElement result = null;
        try {
            if (! super.empty()) {
                result = (PathElement) super.pop();
            } else {
                log.error("stack underflow in PathStack.pop");
            }
        } catch (Exception exc) {
            // cannot occur
        }
        return result;
    } // pop

    /** Search for an element
     *  @param elem1 the element to be looked up on the stack
     *  @return -1 if such an element is not on the stack, or its index if it is
     */
    public int search(PathElement elem1) {
        int result = -1;
        int index = size() - 1;
        try {
            while (index >= 0) {
                PathElement elem2 = (PathElement) get(index);
                if (elem1.equals(elem2)) { // found
                    result = size() - index;
                    index = 0; // stop loop
                } // found
                index --;
            } // while index
        } catch (Exception exc) {
            log.error("unexpected exception during search: " + exc.getMessage(), exc);
        }
        return result;
    } // search

    /** Search for a tuple (typeName, name)
     *  @param typeName name of the type associated with the element
     *  @param name name of the element
     *  @return -1 if such an element is not on the stack, or its index if it is
     */
    public int search(String typeName, String name) {
        int result = -1; // result is 1-based distance from top
        int index  = size() - 1;
        try {
            while (index >= 0) {
                PathElement elem2 = (PathElement) get(index);
                if (    typeName.equals(elem2.getTypeName())
                        &&  name.equals(elem2.    getName())) { // found
                    result = size() - index; // because result is 1-based
                    index = 0; // stop loop
                } // found
                index --;
            } // while index
        } catch (Exception exc) {
            log.error("unexpected exception during search: " + exc.getMessage(), exc);
        }
        return result;
    } // search

    //-----------------------
    // representation methods
    //-----------------------

    /** Get the representation of the XPath to the top stack element
     *  @param separator string between path elements, "/" or " /"
     *  @param start starting index, normally 0, but 2 will omit the 2 top levels in the DOM
     *  @return a string representing the XPath to the top stack element
     */
    public String toString(String separator, int start) {
        StringBuffer result = new StringBuffer(256);
        result.append("XPath=");
        int index = start;
        while (index < size()) {
            PathElement element = (PathElement) get(index);
            result.append(separator);
            result.append(element.getName());
            index ++;
        } // while index
        System.err.println(size() + " " + result.toString());
        return result.toString();
    } // toString

    /** Get the representation of the XPath to the top stack element
     *  @return a string representing the XPath to the top stack element
     */
    public String toString() {
        return toString("/", 0);
    } // toString

} // class PathStack
